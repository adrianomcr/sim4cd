#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# Vehicle geometry definition
# Responsible to compute the collective action of a set of actuators arranged in a given geometric distribution

import time
import numpy as np

import actuators as ACT
import math_utils as MU

class vehicle_geometry:
    """
    Class that represents the geometric collection of actuators of a vehicle
    """

    def __init__(self):
        """
        Constructor for the vehicle_geometry class
        """

        self.cmds = [0, 0, 0, 0] # List of the PWM commands for the actuators
        self.forces = [0, 0, 0, 0] # List of forces being exercised by each actuator
        self.torques = [0, 0, 0, 0] # List of torques being exercised by each actuator
        self.total_force = np.array([0, 0, 0]) # Collective force vector exercised by the actuators
        self.total_torque = np.array([0, 0, 0]) # Collective torque vector exercised by the actuators
        self.d = 0.15 # Lateral distance between the actuators and the vehicle center

        # Actuators configuration
        #    2       0
        #      \ ^ /
        #        |
        #    1 /   \ 3

        # Define the four actuator objects
        act0 = ACT.prop_actuator(1) # spins clock wise
        act1 = ACT.prop_actuator(1) # spins clock wise
        act2 = ACT.prop_actuator(-1) # spins counter clock wise
        act3 = ACT.prop_actuator(-1) # spins counter clock wise
        # Define the list of actuator objects
        self.actuators = [act0,
                          act1,
                          act2,
                          act3]

        # Define a list with the position (with respect to the body frame) of each actuator
        self.positions = [np.array([self.d, -self.d, 0]),
                          np.array([-self.d, self.d, 0]),
                          np.array([self.d, self.d, 0]),
                          np.array([-self.d, -self.d, 0])]

        # Define a list with the direction (with respect to the body frame) of each actuator
        self.directions = [np.array([0.05, 0.05, 1]),
                           np.array([0, 0, 1]),
                           np.array([0, 0, 1]),
                           np.array([0, 0, 1])]
        # Make sure all of the directions are unit norm vectors
        for i, act in enumerate(self.actuators):
            self.directions[i] = MU.normalize(self.directions[i])

        # Initialize the last time variable for time step computation
        self.last_time = time.time()


    def vehicle_sim_step(self, cmds_):
        """
        Constructor for the vehicle_geometry class

        Parameters:
            cmds_ (list): List of PWM values (from 0 to 1) for the actuators

        Returns:
            self.total_force (numpy.ndarray): Collective force the vehicle is receiving from the actuators [N]
            self.total_torque (numpy.ndarray): Collective torque the vehicle is receiving from the actuators [Nm]
        """

        # Set the received command
        self.cmds = cmds_

        # Compute the simulation time step
        time_now = time.time()
        dt = time_now-self.last_time
        self.last_time = time_now
        # Reset actuator it it was not receiving commands for a while TODO: check necessity
        if(dt > 1):
            self.reset()
        
        # Compute the forces and torques generated by each actuator
        for i, act in enumerate(self.actuators):
            self.forces[i], self.torques[i] = self.actuators[i].actuator_sim_step(self.cmds[i])

        # Initialize the computation of the collective force and torque
        self.total_force = np.array([0, 0, 0])
        self.total_torque = np.array([0, 0, 0])
        # Include the contribution of each actuator to the collective force and torque
        for i, act in enumerate(self.actuators):
            # Include vehicles body force generated by the actuator force
            self.total_force = self.total_force + self.forces[i]*self.directions[i]
            # Include vehicles body torque generated by the actuator force
            self.total_torque = self.total_torque + self.forces[i]*np.cross(self.positions[i],self.directions[i])
            # Include vehicles body torque generated by the actuator torque
            self.total_torque = self.total_torque + self.torques[i]*self.directions[i]

        # Return the collective force and torque the vehicle is receiving from the actuators
        return self.total_force, self.total_torque


    def reset(self):
        """
        Reset the forces the vehicles actuators are producing
        """

        # Reset actuators
        for i, act in enumerate(self.actuators):
            self.actuators[i].reset()
        
        # Reset total force and torque
        self.total_force = np.array([0, 0, 0])
        self.total_force = np.array([0, 0, 0])


    def get_cmds(self):
        """
        Get the commands list
        
        Returns:
            self.cmds (numpy.ndarray): List with commands of each actuator [PWM]
        """

        return self.cmds


    def get_force(self):
        """
        Get the collective force (in body frame) the vehicles actuators are producing
        
        Returns:
            self.total_force (numpy.ndarray): Collective force vector the actuators are exercising [N]
        """

        return self.total_force


    def get_torque(self):
        """
        Get the collective torque (in body frame) the vehicles actuators are producing
        
        Returns:
            self.total_torque (numpy.ndarray): Collective torque vector the actuators are exercising [Nm]
        """
        
        return self.total_torque


    def get_actuators_positions(self):
        """
        Get a list with the angular positions of the actuators
        
        Returns:
            self.total_torque (numpy.ndarray): Collective torque vector the actuators are exercising [Nm]
        """

        ang_pos_list = [a.get_angular_position() for a in self.actuators]
        
        return ang_pos_list


    def get_acc_noise_combined(self):
        """
        Get the combined noise the actuators inject on the vehicle's acceleration
        
        Returns:
            acc_combined_noise (numpy.ndarray): Collective acceleration (3-axis) noise caused by the set of actuators [m/s2]
        """

        # Add the acceleration noise induced by all of the actuators
        acc_combined_noise = sum(a.acc_induced_noise() for a in self.actuators)

        return acc_combined_noise # [m/s2]


    def get_gyro_noise_combined(self):
        """
        Get the combined noise the actuators inject on the vehicle's angular speed
        
        Returns:
            gyro_combined_noise (numpy.ndarray): Collective angular speed (3-axis) noise caused by the set of actuators [rad/s]
        """

        # Add the angular speed noise induced by all of the actuators
        gyro_combined_noise = sum(a.gyro_induced_noise() for a in self.actuators)

        return gyro_combined_noise


    def get_total_current(self):
        """
        Get the combined current used by all of the actuators
        
        Returns:
            total_current (float): Total current being consumed by all of the actuators [A]
        """

        # Add the current being consumed by all of the actuators
        total_current = sum(a.current for a in self.actuators)

        return total_current


    def get_mag_noise(self):
        """
        Get the internal magnetic noise caused by the total internal current
        
        Returns:
            mag_noise (numpy.ndarray): Internal magnetic field (3-axis) cause by internal currents [G]
        """

        # Compute the internal magnetic field
        mag_noise = np.array([-0.14, -0.02, -0.08])*(self.get_total_current()/40)**2 #TODO: improve model

        return mag_noise