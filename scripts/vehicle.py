#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# Vehicle geometry definition
# Responsible to compute the collective action of a set of actuators arranged in a given geometric distribution

import time
import numpy as np

import actuators as ACT
import math_utils as MU

class vehicle_geometry:
    """
    Class that represents the geometric collection of actuators of a vehicle
    """

    def __init__(self):
        """
        Constructor for the vehicle_geometry class
        """

        self.cmd = [0, 0, 0, 0] # List of the PWM commands for the actuators
        self.forces = [0, 0, 0, 0] # List of forces being exercised by each actuator
        self.torques = [0, 0, 0, 0] # List of torques being exercised by each actuator
        self.total_force = np.array([0, 0, 0]) # Collective force vector exercised by the actuators
        self.total_torque = np.array([0, 0, 0]) # Collective torque vector exercised by the actuators
        self.d = 0.15 # Lateral distance between the actuators and the vehicle center

        # Actuators configuration
        #    2       0
        #      \ ^ /
        #        |
        #    1 /   \ 3

        # Define the four actuator objects
        act0 = ACT.prop_actuator(1) # spins clock wise
        act1 = ACT.prop_actuator(1) # spins clock wise
        act2 = ACT.prop_actuator(-1) # spins counter clock wise
        act3 = ACT.prop_actuator(-1) # spins counter clock wise
        # Define the list of actuator objects
        self.actuators = [act0,
                          act1,
                          act2,
                          act3]

        # Define a list with the position (with respect to the body frame) of each actuator
        self.positions = [np.array([self.d, -self.d, 0]),
                          np.array([-self.d, self.d, 0]),
                          np.array([self.d, self.d, 0]),
                          np.array([-self.d, -self.d, 0])]

        # Define a list with the direction (with respect to the body frame) of each actuator
        self.directions = [np.array([0, 0, 1]),
                           np.array([0, 0, 1]),
                           np.array([0, 0, 1]),
                           np.array([0, 0, 1])]
        # Make sure all of the directions are unit norm vectors
        for i, act in enumerate(self.actuators):
            self.directions[i] = MU.normalize(self.directions[i])

        # Initialize the last time variable for time step computation
        self.last_time = time.time()


    def vehicle_sim_step(self, cmds_):
        """
        Constructor for the vehicle_geometry class

        Parameters:
            cmds_ (list): List of PWM values (from 0 to 1) for the actuators

        Returns:
            self.total_force (numpy.ndarray): Collective force the vehicle is receiving from the actuators [N]
            self.total_torque (numpy.ndarray): Collective torque the vehicle is receiving from the actuators [Nm]
        """

        # Set the received command
        self.cmds = cmds_

        # Compute the simulation time step
        time_now = time.time()
        dt = time_now-self.last_time
        self.last_time = time_now
        # Reset actuator it it was not receiving commands for a while TODO: check necessity
        if(dt > 1):
            self.reset()
        
        # Compute the forces and torques generated by each actuator
        for i, act in enumerate(self.actuators):
            self.forces[i], self.torques[i] = self.actuators[i].actuator_sim_step(self.cmds[i])

        # Initialize the computation of the collective force and torque
        self.total_force = np.array([0, 0, 0])
        self.total_torque = np.array([0, 0, 0])
        # Include the contribution of each actuator to the collective force and torque
        for i, act in enumerate(self.actuators):
            # Include vehicles body force generated by the actuator force
            self.total_force = self.total_force + self.forces[i]*self.directions[i]
            # Include vehicles body torque generated by the actuator force
            self.total_torque = self.total_torque + self.forces[i]*np.cross(self.positions[i],self.directions[i])
            # Include vehicles body torque generated by the actuator torque
            self.total_torque = self.total_torque + self.torques[i]*self.directions[i]

        # Return the collective force and torque the vehicle is receiving from the actuators
        return self.total_force, self.total_torque


    def reset(self):
        """
        Reset the forces the vehicles actuators are producing
        """

        # Reset actuators
        for i, act in enumerate(self.actuators):
            self.actuators[i].reset()
        
        # Reset total force and torque
        self.total_force = np.array([0, 0, 0])
        self.total_force = np.array([0, 0, 0])


    def get_force(self):
        """
        Get the collective force (in body frame) the vehicles actuators are producing
        
        Returns:
            self.total_force (numpy.ndarray): Collective force vector the actuators are exercising [N]
        """

        return self.total_force


    def get_torque(self):
        """
        Get the collective torque (in body frame) the vehicles actuators are producing
        
        Returns:
            self.total_torque (numpy.ndarray): Collective torque vector the actuators are exercising [Nm]
        """
        
        return self.total_torque