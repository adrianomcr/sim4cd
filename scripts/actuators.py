#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# Actuator modeling
# Forces and torques generated by an actuator (ESC/motor/propeller)

from math import pi, sin
import time
import numpy as np
import math_utils as MU

class prop_actuator:
    """
    Class that represents a propulsion actuator
    It simulates the overall behavior of a set with an ESC, a motor, and a propeller
    """

    def __init__(self, params, act_id):
        """
        Constructor for the prop_actuator class

        Parameters:
            params (<parameter_server.parameter_server>): Parameter server object
            act_id (int): Id of the actuator instance that is used to load the correct parameters
        """

        # Load model parameters
        self.load_parameters(params, act_id)

        self.id = act_id # store the id of the actuator
        self.state = False # on or off TODO
        self.speed = 0.0 # rotation speed # [rad/s]
        self.position = 0.0 # angular position # [rad]
        self.current = 0.0 # current being consumed by the actuator # [A]
        self.cmd = 0 # PWM command [0.0, 1.0] for the actuator
        self.motor_kv = self.volt_to_speed/(2*pi)*60 # Kv of the actuators motor TODO: Not used, remove?

        # Initialize the last time variable for time step computation
        self.last_time = time.time()


    def load_parameters(self, params, act_id):
        """
        Load parameters for the actuator with id act_id and store them in the instance variables

        Parameters:
            params (<parameter_server.parameter_server>): Parameter server object that contains the values of interest
            act_id (int): Id of the actuator whose parameters will be loaded
        """

        self.spin = params.get_parameter_value(f"ACT{act_id}_SPIN")
        self.time_cte = params.get_parameter_value(f"ACT{act_id}_TIME_CTE")
        self.volt_to_speed = params.get_parameter_value(f"ACT{act_id}_VOLT2SPEED_1")
        self.speed_to_thrust = params.get_parameter_value(f"ACT{act_id}_SPEED2THRUST_1")
        self.speed_to_torque = params.get_parameter_value(f"ACT{act_id}_SPEED2TORQUE_1")
        self.torque_to_current = params.get_parameter_value(f"ACT{act_id}_TORQUE2AMPS_1")
        self.Jr = params.get_parameter_value(f"ACT{act_id}_MOI_ROTOR")

        return


    def actuator_sim_step(self, cmd_, V_):
        """
        Perform the dynamic integration step for the actuator

        Parameters:
            cmd_ (float): PWM value (from 0 to 1) for the actuator
            V_ (float): Voltage in the output of the battery [V]

        Returns:
            self.force_map() (float): Force the actuator is producing on the vehicle [N]
            self.torque_map() (float): Torque the actuator is producing on the vehicle [M*m]
        """

        # Set the received command
        self.cmd = cmd_
        # Set the received battery voltage
        self.bat_voltage = V_

        # Compute the simulation time step
        time_now = time.time()
        dt = time_now-self.last_time
        self.last_time = time_now
        # Reset actuator it it was not receiving commands for a while TODO: check necessity
        if(dt > 1):
            self.reset()
        
        # Compute the new angular position given the current speed
        self.position = self.position + self.speed*dt
        # Compute the new speed given the first order dynamics
        self.speed = self.dynamics(dt)
        # Compute the current being consumed by the actuator
        self.current = self.current_map()

        # Return the force and the torque the actuator is inducing on the vehicle
        return self.force_map(), self.torque_map()


    def dynamics(self,dt):
        """
        Simulate the first order dynamics of an actuator

        Parameters:
            dt (float): Time step [s]

        Returns:
            new_speed (float): New rotational speed after a time step [rad/s]
        """

        # Compute the speed in the current time step by considering a first order dynamics
        new_speed = ((self.time_cte-dt)/self.time_cte)*self.speed + (dt/self.time_cte)*self.speed_map()

        return new_speed # [rad/s]


    def speed_map(self):
        """
        Get the stabilization speed given a value of actuator command

        Returns:
            speed (float): Stabilization speed given a actuator command value [rad/s]
        """

        # Compute the speed map
        speed = self.volt_to_speed*(self.cmd*self.bat_voltage) # TODO: Improve model
        
        return speed # rad/s


    def force_map(self):
        """
        Get the force the actuator produces given its rotational speed

        Returns:
            force (float): Force produced by the actuator at the current rotational speed [N]
        """

        # Compute the force map
        force = self.speed_to_thrust*self.speed
        
        return force # [N]


    def torque_map(self):
        """
        Get the torque the actuator produces given its rotational speed

        Returns:
            torque (float): Torque produced by the actuator at the current rotational speed [Nm]
        """

        # Compute the torque map
        torque = -self.spin*self.speed_to_torque*self.speed

        return torque # [Nm]


    def current_map(self):
        """
        Get the current the actuator is consuming given the torque it is generating

        Returns:
            current (float): Current being consumed by the actuator [A]
        """

        # Compute current map
        current = self.torque_to_current*abs(self.torque_map()) # TODO: Improve model
        # https://www.mad-motor.com/products/mad-components-5015-ipe-v3.html

        return current


    def reset(self):
        """
        Reset the actuator by setting its rotational speed to 0
        """

        # Reset actuator
        self.speed = 0


    def get_rpm(self):
        """
        Get the current actuator rotational speed [RPM]
        
        Returns:
            (float): Actuator rotation speed in Rotation Per Minute [RPM]
        """

        return self.speed*60/(2*pi)


    def get_hz(self):
        """
        Get the current actuator rotational speed [Hz]
        
        Returns:
            (float): Actuator rotation speed in Hertz [Hz]
        """

        return self.speed/(2*pi)


    def get_omega(self):
        """
        Get the current actuator rotational speed [rad/s]
        
        Returns:
            (float): Actuator rotation speed in radians per second [rad/s]
        """

        return self.speed


    def get_angular_momentum(self):
        """
        Get the (signed) angular momentum of the actuator around the vector that points in the direction of the propulsion.
        
        Returns:
            L (float): Actuator signed angular momentum in kilograms meter square per second [kg*m*m/s]. The sign indicates the if the the actuator has a positive rotation around the direction of propulsion or a negative rotation.
        """

        # Compute the signed angular momentum
        L = self.spin*self.get_omega()*self.Jr

        return L


    def get_spin(self):
        """
        Get the direction of rotation around the directions axes of the propulsion.
        
        Returns:
            (int): Direction of spin
                    (1): Rotates positively (counter-clockwise) around the vector of propulsion.
                   (-1): Rotates negatively (clockwise) around the vector  of propulsion.
        """

        return self.spin


    def get_angular_position(self):
        """
        Get the current angular position of the actuator [rad]
        
        Returns:
            (float): Actuators angular position in radians [rad]
        """

        return self.position


    def acc_induced_noise(self):
        """
        Compute the noise the actuator is inducing on the vehicle's acceleration [m/s2]
        
        Returns:
            current_noise (numpy.ndarray): Noise induced on the vehicle's (3-axis) acceleration [m/s2]
        """

        # Asymmetry vector on the different axis
        acc_noise_distribution = MU.normalize(np.array([0.9, 1.2, 1.1]))

        # Compute noise overall amplitude based on the actuator's rotation speed
        noise_amplitude = self.speed/280 #TODO: improve amplitude map

        # Compute the influence of the actuator's angular position on the instantaneous noise
        noise_phase = sin(self.position)+sin(2*self.position)/2+sin(3*self.position)/5 #TODO: improve spectrum

        # Compute the (3-axis) noise on the acceleration
        current_noise = noise_amplitude*noise_phase*acc_noise_distribution

        return current_noise # [m/s2]


    def gyro_induced_noise(self):
        """
        Compute the noise the actuator is inducing on the vehicle's angular speed [rad/s]
        
        Returns:
            current_noise (numpy.ndarray): Noise induced on the vehicle's (3-axis) rotational speed [rad/s]
        """

        # Asymmetry vector on the different axis
        gyro_noise_distribution = MU.normalize(np.array([1.5, 0.6, 0.75])) # TODO: Relate to the vehicle moment of inertia

        # Compute noise overall amplitude based on the actuator's rotation speed
        noise_amplitude = self.speed/1450 #TODO: improve amplitude map

        # Compute the influence of the actuator's angular position on the instantaneous noise
        noise_phase = sin(self.position)+sin(2*self.position)/2+sin(3*self.position)/5 #TODO: improve spectrum

        # Compute the (3-axis) noise on the angular velocity
        current_noise = noise_amplitude*noise_phase*gyro_noise_distribution

        return current_noise # [rad/s]