#!/usr/bin/env python3
# -*- coding:utf-8 -*-

# Actuator modeling
# Forces and torques generated by an actuator (ESC/motor/propeller)

from math import pi
import time

class prop_actuator:
    """
    Class that represents a propulsion actuator
    It simulates the overall behavior of a set with an ESC, a motor, and a propeller
    """

    def __init__(self, cw_ccw):
        """
        Constructor for the prop_actuator class

        Parameters:
            cw_ccw (float): Signal unit flag (-1 or 1) indicating the direction of rotation of the actuator
                            Use -1 for clock wise and 1 for counter clock wise
        """

        self.time_cte = 0.02 # Tie constant for the motor first order dynamics [s]
        self.state = False # on or off TODO
        self.speed = 0.0 # rotation speed # [rad/s]
        self.sig = cw_ccw # direction of rotation (clock wise (-1) of counter clock wise (1))
        self.cmd = 0 # PWM command [0.0, 1.0] for the actuator
        self.motor_kv = 320 # Kv of the actuators motor TODO: Check if implementation will use it

        # Initialize the last time variable for time step computation
        self.last_time = time.time()


    def actuator_sim_step(self, cmd_):
        """
        Perform the dynamic integration step for the actuator

        Parameters:
            cmd_ (float): PWM value (from 0 to 1) for the actuator

        Returns:
            self.force_map() (float): Force the actuator is producing on the vehicle
            self.torque_map() (float): Torque the actuator is producing on the vehicle
        """

        # Set the received command
        self.cmd = cmd_

        # Compute the simulation time step
        time_now = time.time()
        dt = time_now-self.last_time
        self.last_time = time_now
        # Reset actuator it it was not receiving commands for a while TODO: check necessity
        if(dt > 1):
            self.reset()
        
        # Compute the new speed given the first order dynamics
        self.speed = self.dynamics(dt)

        # Return the force and the torque the actuator is inducing on the vehicle
        return self.force_map(), self.torque_map()


    def dynamics(self,dt):
        """
        Simulate the first order dynamics of an actuator

        Parameters:
            dt (float): Time step [s]

        Returns:
            new_speed (float): New rotational speed after a time step [rad/s]
        """

        # Compute the speed in the current time step by considering a first order dynamics
        new_speed = ((self.time_cte-dt)/self.time_cte)*self.speed + (dt/self.time_cte)*self.speed_map()

        return new_speed # [rad/s]


    def speed_map(self):
        """
        Get the stabilization speed given a value of actuator command

        Returns:
            speed (float): Stabilization speed given a actuator command value [rad/s]
        """

        # Compute the speed map
        speed = 800*self.cmd # TODO: Improve model
        
        return speed # rad/s


    def force_map(self):
        """
        Get the force the actuator produces given its rotational speed

        Returns:
            force (float): Force produced by the actuator at the current rotational speed [N]
        """

        # Compute the force map
        force = 12*self.speed/800
        
        return force # [N]


    def torque_map(self):
        """
        Get the torque the actuator produces given its rotational speed

        Returns:
            torque (float): Torque produced by the actuator at the current rotational speed [Nm]
        """

        # Compute the torque map
        torque = -self.sig*0.72*self.speed/800

        return torque # [Nm]


    def reset(self):
        """
        Reset the actuator by setting its rotational speed to 0
        """

        # Reset actuator
        self.speed = 0


    def get_rpm(self):
        """
        Get the current actuator rotational speed [RPM]
        
        Returns:
            (float): Actuator rotation speed in Rotation Per Minute [RPM]
        """

        return self.speed*60/(2*pi)


    def get_hz(self):
        """
        Get the current actuator rotational speed [Hz]
        
        Returns:
            (float): Actuator rotation speed in Hertz [Hz]
        """

        return self.speed/(2*pi)


    def get_omega(self):
        """
        Get the current actuator rotational speed [rad/s]
        
        Returns:
            (float): Actuator rotation speed in radians per second [rad/s]
        """

        return self.speed
